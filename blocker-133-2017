#!/usr/bin/perl

use v5.10;
use strict;
use warnings;
use Getopt::Std;
use Net::OpenSSH;
use Net::Telnet;
use Net::IP::Match::Regexp qw( create_iprange_regexp match_ip );
use Text::Diff;
use IPC::Open3;

my @asnum = (
    'AS47541', # VKONTAKTE-SPB-AS
    'AS47764', # mailru-as
    'AS13238', # Yandex
    'AS43247', # YAMONEY-AS
    'AS197068', # QRATOR (drweb.ru)
    'AS200107'  # KL-EXT (kaspersky.ru)
);

my $fhostnames = 'hostnames';
my $fhostip = 'hostip';
my $fhostipdiff = 'hostipdiff';
my $fiphost = 'hostip.hostname';

my ($rr_ht, $rr_rt, $rr_jn, $rr_old_config, $rr_new_config, %ipnet, @ipnet) = ("", "", "", "", "");
my (%hostip, $fh, $fho, $hostip, $hostipold);

my %opts;
getopts('u:p:r:', \%opts);
unless (defined $opts{r} ) {
    say "-rrouter";
    exit 254;
}
unless (defined $opts{u} ) {
    say "-uusername";
    exit 254;
}
unless (defined $opts{p} ) {
    say "-ppassword";
    exit 255;
}

# Отримуємо список заблокованих ip-адрес та мереж на бордері
$hostipold = join("\n", getJunOSRejectStaticRoute($opts{r}, $opts{u}, $opts{p}));
$rr_old_config = join("\n", sort( map { "set routing-options static route ".$_." reject" } split("\n", $hostipold) ) );

# читаємо список хостів для блокування та записуємо зв'язки ip в ім'я
open $fh,"<:utf8", $fhostnames or die "Can't open file $fhostnames :$!\n";
open $fho,">>:utf8", $fiphost or die "Can't open file $fiphost :$!\n";
while (<$fh>) {
    next unless /^.+$/;
    next if /^\s*#/;
    chomp;
    my @hosts = getHostIP($_);
    foreach my $rr (@hosts) {
        $hostip{$rr}++;
        print $fho sprintf("%s %s\n", $rr, $_);
    }
}
close $fho;
close $fh;
system(sprintf("sort -u %s | sort -u -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n > /tmp/%s", $fiphost, $fiphost."~" ));
system(sprintf("mv /tmp/%s %s", $fiphost."~", $fiphost ));

# отримуємо список мереж для блокування (по AS-num)
foreach my $asnet (@asnum) {
    my $rt_rn = getRTRejectStaticRoute($asnet);
say $rt_rn;
    map {
	if (m{/32$}) {
say;
	    my ($net, $mask) = split("/", $_);
	    $ipnet{$net} = $mask if $mask<$ipnet{$net};
	}
    } split("\n", $rt_rn);
}
foreach my $net ( sortipv4( keys %ipnet ) ) {
    $rr_rt .= sprintf("set routing-options static route %s/%s reject\n", $net, $ipnet{$net});
    push @ipnet, sprintf("%s/%s", $net, $ipnet{$net});
}
my $ipnetre = create_iprange_regexp( @ipnet );
$rr_new_config .= $rr_rt;

# список блокуємих ip-адрес, що виявлено за цей сеанс
foreach my $ip ( sortipv4(keys %hostip) ) {
    unless (match_ip($ip, $ipnetre)) {
	$rr_ht .= sprintf("set routing-options static route %s reject\n", $ip);
    }
}
$rr_new_config .= $rr_ht;

# зчитуємо заблоковані хости (/32) з маршрутизатора.
# якщо вони входять в заблоковані мережі - видаляємо маршрут на хост
# формуємо нову конфігурацію
foreach my $ip ( getJunOSRejectHostStaticRoute($opts{r}, $opts{u}, $opts{p}) ) {
    if (match_ip($ip, $ipnetre)) {
	$rr_jn .= sprintf("delete routing-options static route %s\n", $ip);
    } else {
	$rr_jn .= sprintf("set routing-options static route %s reject\n", $ip);
    }
}
$rr_new_config .= $rr_jn;
$rr_new_config =~ s,/32\s+, ,m;
$rr_new_config = join("\n", sort( split("\n", $rr_new_config) ) );

$rr_old_config = sortwithoutdup($rr_old_config);
$rr_new_config = sortwithoutdup($rr_new_config);

my $diff = diff \$rr_old_config, \$rr_new_config;

open $fh,">:utf8", $fhostipdiff or die "Can't open file $fhostipdiff :$!\n";
print $fh $diff;
close $fh;

open $fh,">:utf8", $fhostip or die "Can't open file $fhostip :$!\n";
print $fh join("\n", getJunOSRejectStaticRoute($opts{r}, $opts{u}, $opts{p}));
close $fh;

print $diff;
#setJunOSConfig($diff, $opts{r}, $opts{u}, $opts{p}) if length($diff)>0;

exit;

sub setJunOSConfig {
    my $diff = shift;
    my $router = shift if @_;
    my $user = shift if @_;
    my $pass = shift if @_;

    my $ret = "";
    foreach my $line ( split("\n", $diff) ) {
        next unless $line =~ /^[+-]/;
        $line =~ s/;$//;
        if ($line =~ /^-/) {
            $line =~ s/^-//;
#            $ret .= $line."\n";
        } else {
            $line =~ s/^\+//;
            $ret .= $line."\n";
        }
    }
    doCmd( $router, $user, $pass, $ret );
    return $ret;
}

sub doCmd {
    my $router = shift if @_;
    my $user = shift if @_;
    my $pass = shift if @_;
    my $cmdin = shift if @_;

    sub diessh {
        map { print; } @_ if @_;
        die;
    }

    return unless length($cmdin)>0;

#   open STDERR, '>', "/dev/null";
    my $ssh = Net::OpenSSH->new( $router, user => $user, password => $pass, master_opts => [-o => "StrictHostKeyChecking=no"] );
    $ssh->error && die "Couldn't establish SSH connection: ". $ssh->error;
    my ($pty, $pid) = $ssh->open2pty();
    my $session = Net::Telnet->new( -fhopen => $pty, -prompt => '/.*[>#]\s+$/', -timeout=>60 );
    $session->waitfor(-match => $session->prompt, -errmode => "return") || diessh "wait failed: " . $session->lastline;
    $session->cmd(String=>'configure private');
    my $cmdc = 0;
    foreach my $cmd ( split "\n", $cmdin ) {
        $session->waitfor(-match => $session->prompt, -errmode => "return") || diessh "wait failed: " . $session->lastline;
        $session->cmd(String=>$cmd);
        say "".$cmd;
        $cmdc++;
        sleep 1;
    }
    $session->waitfor(-match => $session->prompt, -errmode => "return") || diessh "wait failed: " . $session->lastline;
    $session->cmd(String=>'commit and-quit', Timeout=>10*$cmdc);
    $session->waitfor(-match => $session->prompt, -errmode => "return") || diessh "wait failed: " . $session->lastline;
    $session->close;
    waitpid($pid, 0);
    undef $session;
    undef $ssh;
#   open STDERR, '>', "/dev/stderr";
}

sub getJunOSRejectHostStaticRoute {
    my $router = shift if @_;
    my $user = shift if @_;
    my $pass = shift if @_;

    my $ssh = Net::OpenSSH->new( $router, user => $user, password => $pass, master_opts => [-o => "StrictHostKeyChecking=no"] );
    $ssh->error && die "Couldn't establish SSH connection: ". $ssh->error;
    my @ret = split("\n", join("", jCmd($ssh, sprintf("show configuration routing-options static | display set | match /32 | match reject\$ | no-more")) ));
    undef $ssh;
    return sortipv4(@ret);
}

sub getJunOSRejectStaticRoute {
    my $router = shift if @_;
    my $user = shift if @_;
    my $pass = shift if @_;

    my $ssh = Net::OpenSSH->new( $router, user => $user, password => $pass, master_opts => [-o => "StrictHostKeyChecking=no"] );
    $ssh->error && die "Couldn't establish SSH connection: ". $ssh->error;
    my @ret = split("\n", join("", jCmd($ssh, sprintf("show configuration routing-options static | display set | match reject\$ | no-more")) ));
    undef $ssh;

    return sortipv4(@ret);
}

sub getRTRejectStaticRoute {
    my $as = shift if @_;
    return "" unless $as;
    my $ret;
#1    open (RT, 'echo "@rtconfig printPrefixRanges \"set routing-options static route %p/%m reject\n\" filter '.$as.'" | /usr/local/bin/rtconfig -protocol ripe -config junos |') || die "Failed run rtconfig: $!\n";
    open (RT, 'echo "@rtconfig printPrefixRanges \"%p/%m\n\" filter '.$as.'" | /usr/local/bin/rtconfig -protocol ripe -config junos |') || die "Failed run rtconfig: $!\n";
    while (<RT>) {
        s/^\s*//;
        next unless /^set\s+/;
        $ret .= $_;
    }
    close RT;
    return $ret;
}

sub jCmd {
    my $ssh = shift if @_;
    my $cmd = shift if @_;
    my @list = $ssh->capture($cmd);
    $ssh->error && die "remote '$cmd' command failed: " . $ssh->error;
    return @list;
}

sub getHostIP {
    my $host = shift if @_;
    my @ret;

    return @ret unless $host;

    open3(*WHOIS_HOST_IN, *WHOIS_HOST_OUT, *WHOIS_HOST_ERR, sprintf("dig %s -t a \@8.8.8.8 +nottl", $host));
    close(WHOIS_HOST_IN);
    my @outwhoishost = <WHOIS_HOST_OUT>;
    my @errwhoishost = <WHOIS_HOST_ERR>;
    close(WHOIS_HOST_OUT);
    close(WHOIS_HOST_ERR);

    foreach my $line ( @outwhoishost ) {
        next unless $line =~ /^$host\.\s+IN\s+A\s+/;
        chomp $line;
        my (undef, undef, undef, $ip) = split(" ", $line);
        push @ret, $ip;
    }

    return @ret;
}

sub sortipv4 {
    my @ret = @_;
    map { s/^[^\d]+//; s/[^\d]+$//; s,/32$,,; } @ret;
    @ret = map { join(".",unpack("C5")) } sort map { pack("C5",split /[.\/]/) } @ret;
    map { s,\.(\d+)$,/$1,; s,/0$,,; } @ret;
    return @ret;
}

sub sortwithoutdup {
    my $txt = shift if @_;
    return "" unless $txt;
    my %txt;
    foreach my $t (split("\n", $txt)) {
	$txt{$t}++;
    }
    return join("\n", sort( keys %txt ) );
}
